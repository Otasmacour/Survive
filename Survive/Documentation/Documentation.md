# MVC
The whole game runs on the **MVC** (**Model**-**View**-**Controller**) architecture. Where **Model** takes care of all the logic and all the complex issues. **View** provides purely graphical output and nothing else. The **Controller** is the main game loop, where the mechanics from **Model**(running the game) and **View** (graphical output) are called. 

#### The advantages of the MVC architecture in terms of my usage are as follows:
 - **Clarity** These three main components clearly segment the mechanics of the program, thus avoiding spaghetti code up front.
 - **Easier modifiability** Thanks to the View component, the separated graphical output, it is not difficult to modify the game graphics without requiring changes to the **Model**, the logical side of the game.
# About the documentation 
in my opinion, the vast majority of the code is very readable, and therefore it was often not necessary to write comments in the code itself. in the following documentation I will not discuss everything that happens in the code, because it would often be unnecessary. I will focus on those parts of the code that are more difficult to understand and require more complex reasoning, or are part of mechanics that are spread over multiple places in the code and thus difficult to understand from just one part of the code. I will also explain some of my decisions about why I did a given thing the way I did it.
The entire documentation is written in such a way that it is best understood by having the source code in question open at the same time as reading it.
# Code structure
Code structure.
The code is pretty much segmented and consists of 86 C# files, each for one class, exceptionally not a class but multiple enums.
At the beginning I didn't have it so segmented, but as the volume of code grew, it became difficult to find my way around. 
It's much clearer this way, each class contains exactly the mechanics one would expect from its name (or from the other methods in it, if the name is not quite clear). I followed the rule that if there are too many methods somewhere, and those methods could be split into subsets depending on what they are for, it's time to separate the methods and make their own classes.
This way the code is much more modifiable, it is immediately clear where some new mechanics should belong. It also makes the whole game code more readable, because it's easier to search through it, one just has to click through the folders one by one and eventually find one of the subsets of the mechanics one is looking for.
The way it is implemented is that each class has the classes whose mechanics it needs to use stored at the top as properies. In most cases this works like a pyramid, and classes rarely use the classes "above" them. The fact that there isn't any significant mess in this is ensured by the fact that constructor classes are called in the ones "above".
# Controller
In terms of branching out, the Controller is the top block of the pyramid, below which it branches out into multiple blocks (classes). 
I think one pretty well just needs to read the code in detail throughout the class to get a pretty good idea of how the whole program works. In fact, there are 2 main loops in the Controller, the first of which repeatedly calls the Escape method, which turns the game on, and when the program returns from that method, the player chooses if they want to play again if they lost, and if they won, they are shown the time it took to finish. Calling the Escape method starts an instance of the game that takes place entirely in the other loop, which consists of the 4 main methods for running the game. First the montrum moves, then the screen refreshes, then the player performs an action, and finally the sounds play. In this way, the loop of one game instance runs over and over again until the player runs away from the house or the monster catches him.
There are comments in the code that make understanding the sub-methods much easier.
What can be confusing at first in terms of what it does there and why, are the stopwatches that are used in three of the four sub-methods called in Escape. For the game to work, the mechanics of these three methods must be triggered with some delay. 
I can think of three ways to do this: 
- **Thread**, it's a class that provides a Thread.Sleep(int milliseconds) method that literally puts the program to sleep for a certain number of milliseconds at any given time. Using Thread for my purpose is a pretty terrible idea, the moment you need to manage more than one process (three in my case) it doesn't work together. I tried it and the result was as I expected, the game was stuttering.
- **Asynchronous loops**, it's exactly what it sounds like. Instead of the program running synchronously, it runs in multiple places at the same time. A possibility would be that each time Escape is called, three loops would start, each for one process, and that process would run in that loop. I tried this and it worked, but I ran into the problem that asynchronous loops can't actually be debugged. Normally (when the program is running synchronously), if I index an empty list somewhere, for example, the program will stop and Visual Studio will report an error. On the other hand, when such an error occurs in an asynchronous loop, the whole program freezes and it is very difficult to find out what the error is. That's why I rejected this option.
- **StopWatch**, a built-in class from which instances can be created so I can measure the elapsed time and reset it after startup. In the MonsterAction and DisplayUpdate methods, I use this to check if it's time to start the mechanics again. If it is, the monster moves, or the screen is updates, and then the stopwatch is reset again.
# Map
Since the game is in 2D, I implemented the game field as a two-dimensional array that contains the lists of the GameObject. Because when a player enters a position, both he and the GameObject that was there before he entered are in that position. There could have been more than one GameObject there originally, typically a floor and an item. That's why you need to have a list for that position, where everything that needs to be added is added, not just a slot that gets overwritten.
Map mechanics are divided into several classes according to the problems they handle:
 - **Maps**, the signpost, which branches further and is the main block under which everything about the maps is located. By making this class.
 - **RoomMapCollection**, a place where map information is stored. a list of all maps, a dictionary of maps by floor (which is a subset of that list), and a map where the monster respawns.
 - **MapOperations**, contains methods that manipulate the content of maps. They place items on them and change the player's position on the maps.
 - **MapCleaning**, it takes care of removing unused doors from the maps (it is explained a little bit below what unused doors are).
 - **MapsInitialization**, it creates maps and especially generates those two-dimensional arrays representing the game field.
 - **MapsLinking**, a Map instances are created here. Then there is a method for linking maps. Linking maps means that they link to each other through doors, so that when the player then steps through a door in a room, it moves the player in front of the door of the map where the door leads (the map that the door is linked to).
 - **MapHelper**, another such signpost that has multiple classes underneath it, all of which have in common that they return something and calling them does not directly start any processes that would affect the game itself
  
Classes, that are underneath the **MapHelper**:
 - **BoolFunctions**, most of the methods, that are contained here are used for checking, if something is located at a given coordinates on a given map(to be more specific, in a given two-dimensional array). Some of the methods here are used just once, but in case of expansion of Survive, they could be used again, so they are not useless.7
 - **Parsing**, methods for conversion of **Coordinates** to tupple of two integers, widely used in **TwoDArrayFunctions**. **Coordinates** are objects and even if 2 coordinates would have the same values on x and y, they are not the same objects and therefore it is necessary to convert Coordinates to two integers and then compare them according to x and y values.
 - **ReturnFunctions**, 
This class is quite to **BoolFunctions**, methods for returning certain objects are almost always used in places where the bool method from boolfunctions is used to verify that the object is there, for example **GetDistanceOfTwoMaps()**
 - **TwoDArrayFunctions** contains the methods necessary for the Monster to work in the game.

 I will explain, how the more complex ones work:

 - **TwoDArrayBFS** method whose output for a given two-dimensional array is all reachable positions(in int x and int y) in the array, for a given starting position. For each such position, the output is also an integer indicating the depth for that position(the minimum possible number of steps to reach the given position from a given position with depth, in this case the starting position is the second argument of Coordinates "start"). The algorithm that assigns depth to the game field positions works on the principle of BFS (breadth-first search). Classically, a queue is created where the positions that the algorithm has reached are added and then the surrounding positions are searched from that position. In the GetAdjacentCoordinates method, the argument int 4 is used, which means that it will return only four surrounding positions for a given position, not 8(so it returns top, bottom, left and right). This is due to the way the monster walks, if the monster also walked diagonally then 8 would be used as the argument.
The possible cases that can occur for a neighbouring position are 3.
1. The monster can enter the position and the position has not been visited yet => the depth is set (to the value of the position from which it is currently looking at the neighboring one + 1) and it is added to the queue.
2. The position has not yet been visited and there is a door at that position => depth is set. Why isn't it added to the queue as well? Because the door only ever has 3 adjacent positions from the way the monster moves, it's on the edge of the playfield and at the same time 2 of those 2 are walls in the wall where the door is. So the only adjacent position of the door that could theoretically be entered would be the position from which the door could be accessed. If the depth of the position from which one could get to the door was n, the depth of the door position would be n+1. And then looking from that door position to the adjacent one (the only one available where there is a floor and a wall would be the one with depth n) and checking to see if the depth of door position +1 is less than the adjacent one would make it look like n + 2 is less than n. Since this doesn't hold, there's no point in adding that door position to the queue at all.
3. The position has already been visited and the monster can enter it. In this case, the value viewed will be changed and added to the queue if the following condition holds. The depth n of the position being viewed satisfies that n + 1 is less than the depth of the position being viewed, which would mean that a shorter path has been found.

# What could I have done better + possible improvements for the future
This project is not perfect and is much bigger than anything I have done before. In making it, I basically locked myself in my room for half of the summer of 2023. I didn't follow any instructions for making the game and only watched a short video about what a model-view-controller is, after Petr Vincena told me I should follow this architecture. So apart from the **MVC** pattern, the rest of the game's architecture is completely off the top of my head, and since I've moved on a bit in programming since writing Survive, I can see things in hindsight that could have been done better.
- **Unnecessary re-creation of an unnecessarily high number of classes and not using of static classes**
To be honest, while making off, I didn't know about the existence of static class feature, or at least I didn't know, what they are good for. Lots of the classes could be static without need of regenerating of them every game instance. Some of them even wouldn't require the existence of methods, to reset the game data inside the game logic to work. For example this classes could be static:
    - Every class underneath the **MapHelper**
    -  **DataIOManager** classes 
    -  **Alerts**
    -  **SoundsController**
- **Multiplayer**
The game could use some multiplayer for 2 or more players. The second player could play as a monster. The question arises, how could one guarantee the smooth running of the game, or that the player playing as the monster would not step right in front of the main door? It could be done in such a way that the player playing as the monster would periodically get some tasks like he has to go to some place and check something, and if he doesn't show up he would be limited somehow. Maybe his movement speed would be reduced. So the player playing as the monster would have an incentive to not just stay at the door. Of course, as the game is now, it wouldn't be as fun and would require more items to be added for fun multiplayer, more on that in the point below. 
- **Another Items**
A large number of items could be added to the game. For one thing, you could add lots of new chests and similar bodies that require items to unlock or perform other actions, potentially resulting in lots of new items.
Items could also be created for independent use. Compas that would show the player the approximate location of the monster when used. Freezing grenades that would freeze the monster for a few seconds when hit. Remote-controlled firecrackers that the player could set off from several rooms away to lure the monster to a location where it is no longer present.
An item that I thought of beforehand, but didn't end up adding, is some sort of barricade that the player can place somewhere on the floor to prevent the monster from passing through that spot. By just placing it somewhere on the floor in the middle of the room, the player wouldn't accomplish anything, because it would bypass the monster (it would require such an item to be included in the **MonsterCanGoThere** method found in **BoolFunctions**). However, if the player placed such a barrier in front of a door, the monster would logically not be able to pass through and would have to choose a path through other rooms if it is heading to a specific location.
There is room for this expansion in the game. The monster's movement is such that he's always heading somewhere, and he always has a sequence of rooms "in it's head" as a path to his destination. When he steps into a room that could be expressed as aN (a member of the sequence), room aN+1 is behind one of the doors in the room it is currently in. The way to get to the door to room aN+1 is to iterate through the list of doors that are on the map and try to see if the **Door** leads to room aN+1. If it does, then take that **Door** as an object and use **Dictionary<Door,Coordinates>** to get the **Coordinates** of the door the monster needs to get to and go through. And those coordinates are then used by doing a breadth-first search for the shortest path for that room. If the result of this algorithm is that the door cannot be reached (this only happens if there is a barricade in front of it), the monster will change its plan. And it does this by generating a new sequence of rooms that might lead to the room it needs to get to, and it doesn't include this particular door that it just found out it can't get through.
- **Bigger house**
Thanks to the user-friendly addition of rooms(creating them in **MapsLinking** eventually creating a custom txt file for a custom room layout), it is not difficult to expand the size of the house. Adding another floor, another secret tunnel could be quite easy.
- **It's not just about Survive**
Much of the gameplay elements are very specific to Survive, a game where the player wants to escape from a house where a monster is chasing them. So a large part of the code is the mechanics for controlling the player character and the movement of the monster. But aside from those elements, there's a general structure of mechanics for creating some sort of object pieced together from multiple rooms. If someone would take the trouble to do that, the entire Survive could be stripped down to mechanics specific to the escape game. And then it could be remade into something else entirely. Either a different 2d terminal game or a simulation. In the case of that simulation, it could easily modify and then use the already existing mechanics of the monster, which would just rename it to a generic entity and probably spawn more instances from it than just one in the case of the monster in Survive.